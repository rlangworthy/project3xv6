
base & freep* are Headers up top




umalloc.c:63-73
63	void*
64	malloc(uint nbytes)
65	{
66	  Header *p, *prevp;
67	  uint nunits;
68
69	  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
70	  if((prevp = freep) == 0){
71	    base.s.ptr = freep = prevp = &base;
72	    base.s.size = 0;
73	  }

Sets up free list on first invocation of malloc

umalloc.c:74-90
74	  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
75	    if(p->s.size >= nunits){
76	      if(p->s.size == nunits)
77	        prevp->s.ptr = p->s.ptr;
78	      else {
79	        p->s.size -= nunits;
80	        p += p->s.size;
81	        p->s.size = nunits;
82	      }
83	      freep = prevp;
84	      return (void*)(p + 1);
85	    }
86	    if(p == freep)
87	      if((p = morecore(nunits)) == 0)
88	        return 0;
89	  }

Traverses the free list looking for the next free space of suitable size.  If 
found, updates the free list appropriately to implement next fit and returns a
pointer to the newly allocated space.  If one is not found, it calls morecore 
to allocate more space to the heap.

umalloc.c:46-54
46	static Header*
47	morecore(uint nu)
48	{
49	  char *p;
50	  Header *hp;
51	
52	  if(nu < 4096)
53	    nu = 4096;
54	  p = sbrk(nu * sizeof(Header));

morecore assigns a minimum of 4096 * sizeof(Header) new bytes to the process 
using sbrk.

sysproc.c:78-90
78	int
79	sys_sbrk(void)
80	{
81	  int addr;
82	  int n;
83
84	  if(argint(0, &n) < 0)
85	    return -1;
86	  addr = myproc()->sz;
87	  if(growproc(n) < 0)
88	    return -1;
89	  return addr;
90	}

Fetches the argument from the stack via argint and stores it in n, uses that as
 the argument for growproc and returns addr, the size of the ond process memory
 and a pointer to the start of the newly allocated memory.



















